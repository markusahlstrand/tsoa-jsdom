"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Router = void 0;
const path_to_regexp_1 = require("path-to-regexp");
/**
 * Cloudworkder-router
 *
 * @example
 * import { Router, Method, Params } from 'cloudworker-router'
 *
 * const router = new Router<Handler>()
 */
class Router {
    constructor() {
        /** List of all registered routes. */
        this.routes = [];
    }
    /** Add a route that matches any method. */
    all(path, handler) {
        return this.push('ALL', path, handler);
    }
    /** Add a route that matches the GET method. */
    get(path, ...handlers) {
        handlers.forEach((handler) => {
            this.push('GET', path, handler);
            this.push('HEAD', path, handler);
        });
        return this;
    }
    /** Add a route that matches the POST method. */
    post(path, ...handlers) {
        handlers.forEach((handler) => {
            this.push('POST', path, handler);
        });
        return this;
    }
    /** Add a route that matches the PUT method. */
    put(path, ...handlers) {
        handlers.forEach((handler) => {
            this.push('PUT', path, handler);
        });
        return this;
    }
    /** Add a route that matches the PATCH method. */
    patch(path, ...handlers) {
        handlers.forEach((handler) => {
            this.push('PATCH', path, handler);
        });
        return this;
    }
    /** Add a route that matches the DELETE method. */
    delete(path, ...handlers) {
        handlers.forEach((handler) => {
            this.push('DELETE', path, handler);
        });
        return this;
    }
    /** Add a route that matches the HEAD method. */
    head(path, ...handlers) {
        handlers.forEach((handler) => {
            this.push('HEAD', path, handler);
        });
        return this;
    }
    /** Add a route that matches the OPTIONS method. */
    options(path, ...handlers) {
        handlers.forEach((handler) => {
            this.push('OPTIONS', path, handler);
        });
        return this;
    }
    /** Add a middlewares handler */
    use(handler) {
        return this.push('ALL', '*', handler);
    }
    /** Add a middlewares for handling options requets */
    allowedMethods() {
        return async (ctx) => {
            const url = new URL(ctx.request.url);
            const allow = {
                OPTIONS: true,
            };
            this.routes.forEach((route) => {
                // Skip catch all
                if (route.method === 'ALL') {
                    return;
                }
                const matches = route.regexp.exec(url.pathname);
                if (!matches || !matches.length) {
                    return;
                }
                allow[route.method] = true;
            });
            return new Response(null, {
                status: 204,
                headers: {
                    allow: Object.keys(allow).join(', '),
                },
            });
        };
    }
    matches(method, path) {
        const results = [];
        this.routes.forEach((route) => {
            // Skip immediately if method doesn't match
            if (route.method !== method && route.method !== 'ALL')
                return;
            const matches = route.regexp.exec(path);
            if (!matches || !matches.length)
                return;
            results.push({ ...route, matches, params: keysToParams(matches, route.keys) });
        });
        return results;
    }
    async handleMatches(ctx, ...routeMatches) {
        const routeMatch = routeMatches.shift();
        if (!routeMatch) {
            return null;
        }
        ctx.params = routeMatch.params;
        return routeMatch.handler(ctx, () => {
            return this.handleMatches(ctx, ...routeMatches);
        });
    }
    async handle(request, env, context) {
        const { pathname, searchParams } = new URL(request.url);
        const matches = this.matches(request.method, pathname);
        const ctx = {
            request,
            query: searchParams,
            headers: request.headers,
            params: {},
            state: {},
            env,
            event: context,
        };
        const response = await this.handleMatches(ctx, ...matches);
        if (!response) {
            return new Response('Not Found', {
                status: 404,
            });
        }
        // Strip body from head requests
        if (request.method === 'HEAD') {
            return new Response('', response);
        }
        return response;
    }
    push(method, path, handler) {
        const keys = [];
        if (path === '*') {
            path = '(.*)';
        }
        const regexp = (0, path_to_regexp_1.pathToRegexp)(path, keys);
        this.routes.push({ method, path: path.toString(), handler, keys, regexp });
        return this;
    }
}
exports.Router = Router;
// Convert an array of keys and matches to a params object
const keysToParams = (matches, keys) => {
    const params = {};
    for (let i = 1; i < matches.length; i++) {
        const key = keys[i - 1];
        const prop = key.name;
        const val = matches[i];
        if (val !== undefined) {
            params[prop] = val;
        }
    }
    return params;
};
//# sourceMappingURL=Router.js.map